/*
 * FengGUI - Java GUIs in OpenGL (http://www.fenggui.org)
 * 
 * Copyright (c) 2005-2009 FengGUI Project
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details:
 * http://www.gnu.org/copyleft/lesser.html#TOC3
 * 
 * Created on 22.11.2007
 * $Id$
 */
package org.fenggui.text.content.part;

import org.fenggui.appearance.TextAppearance;
import org.fenggui.binding.render.Graphics;
import org.fenggui.text.content.IContentFactory;
import org.fenggui.text.content.factory.simple.TextStyle;
import org.fenggui.text.content.factory.simple.TextStyleEntry;
import org.fenggui.util.Dimension;

/**
 * This is a part of the content. This can be anything, Text, Images, URL, ...
 * 
 * <p>
 * Usually this parts are generated by the ContentFactory.
 * </p>
 * 
 * @see IContentFactory
 * 
 * @author marcmenghin, last edited by $Author$, $Date$
 * @version $Revision$
 */
public abstract class AbstractContentPart
{
  private Dimension size          = null;
  private boolean   selected      = false;
  private boolean   hovered       = false;
  private boolean   hideContent   = false;

  private int       beforeLength  = 0;
  private int       afterLength   = 0;
  private String    styleKey      = TextStyle.DEFAULTSTYLEKEY;
  private String    styleStateKey = TextStyleEntry.DEFAULTSTYLESTATEKEY;

  public AbstractContentPart(int beforeLength, int afterLength, String styleKey)
  {
    this.beforeLength = beforeLength;
    this.afterLength = afterLength;
    this.styleKey = styleKey;
  }

  /**
   * Returns True if the content of this Part is breakable. Normally this is true if the
   * AtomCount is greater than one.
   * 
   * @return
   */
  public abstract boolean isSplittable();

  /**
   * Breaks a part into two parts. It fill the max. words into the remaining part.
   * The returned part is everything that didn't fit into the given width. If it is a
   * firstPart and no word fits into the width it will split the first word on the
   * character level. 
   * 
   * @param width
   *          The width this part should fit into.
   * @param onlyPart
   * 				true if this is the only part in a line.
   * @return Returns everything that is too much for the given width.
   */
  public abstract AbstractContentPart splitAtWord(int width, boolean onlyPart, TextAppearance appearance);

  /**
   * Breaks a part into two parts. It fill the max. atoms into the remaining part.
   * The returned part is everything that didn't fit into the given width.
   * 
   * @param width
   *          The width this part should fit into.
   * @param onlyPart
   * 				true if this is the only part in a line.
   * @return Returns everything that is too much for the given width.
   */
  public abstract AbstractContentPart splitAtChar(int width, TextAppearance appearance);

  /**
   * Breaks the part into two parts. It fills the max. atoms into the remaining part.
   * The returned part is everything after the given atom.
   * 
   * @param atom atom to cut after
   * @return Returns everything after the given atom.
   */
  public abstract AbstractContentPart splitAtAtom(int atom, TextAppearance appearance);

  /**
   * Breaks the part into two parts. It fills the max. atoms into the remaining part.
   * The returned part is everything after the given atom.
   * 
   * @param appearance
   * @return Returns everything after the given atom.
   */
  public abstract AbstractContentPart splittAtActivePosition(TextAppearance appearance);

  /**
   * Merges two parts where the canMerge() Method returned true.
   * 
   * @param part
   *          part to merge with this.
   */
  public abstract void mergePart(AbstractContentPart part, TextAppearance appearance);

  /**
   * Checkes if the two parts can be merged or not.
   * 
   * @param part
   * @return
   */
  public abstract boolean canMerge(AbstractContentPart part);

  /**
   * Renders this content Parts content to the position.
   * 
   * @param x
   * @param y
   * @param g
   * @param gl
   */
  public abstract void render(int x, int y, Graphics g, TextAppearance appearance);

  /**
   * Returns the amount of Atoms within this content part.
   * 
   * @return
   */
  public abstract int getAtomCount();

  /**
   * Calculates the position and returns the atom count to this position.
   * 
   * @param x
   *          Position in pixels on screen.
   * @return Position in atoms within content.
   */
  public abstract int calculatePositionInAtoms(int x, TextAppearance appearance);

  /**
   * Returns the position of an atom.
   * 
   * @param atom
   *          Position in atoms within this content part.
   * @return Position in pixels from the content start position (0).
   */
  public abstract int getActivePosition(TextAppearance appearance);

  /**
   * if this returns true then this part can be removed if an other part is at the
   * same line. True means that this part is empty and will not display anything.
   * @return
   */
  public abstract boolean isEmpty();

  /**
   * Returns the position of the currently selected atom. Essentially it is a call to
   * getAtomPosition with the current selected atom as parameter.
   * 
   * @return
   */
  public abstract int getAtomPosition(int atom, TextAppearance appearance);

  /**
   * Returns if this part has an active Atom.
   *  
   * @return
   */
  public abstract boolean hasActiveAtom();

  /**
   * This is called if the user presses a key on the keyboard.
   * 
   * @param c
   *          the character the pressed key represents.
   * @return true if something changed, false otherwise.
   */
  public abstract boolean addChar(char c, TextAppearance appearance);

  /**
   * Adds new content to this part. Usually this is used for pasting
   * content and similar things.
   * 
   * @param content content to add.
   * @return true if content could be added.
   */
  public abstract boolean addContent(String content, TextAppearance appearance);

  /**
   * Removes the following char of the current selected position.
   * 
   * @return returns the removed char or null if none could be removed.
   */
  public abstract Character removeNextAtom(TextAppearance appearance);

  /**
   * Removes the character before the current selected position.
   * 
   * @return returns the removed char or null if none could be removed.
   */
  public abstract Character removePreviousAtom(TextAppearance appearance);

  /**
   * Sets the currently selected Atom. Set it to -1 to remove the selection.
   * 
   * @param atom
   */
  public abstract void setActiveAtom(int atom);

  /**
   * Returns the active position or -1 if none.
   * 
   * @return active position (in atoms) or -1 for none.
   */
  public abstract int getActiveAtom();

  
  /**
   * Returns true if the given character is valid within this content part, false otherwise.
   * 
   * @param character
   * @param appearance
   * @return
   */
  public abstract boolean isValidCharacter(char character, TextAppearance appearance);
  
  /**
   * Returns the content of this contentPart in a reproducible form. Creating a new
   * content part with this String should result in the same content being displayed.
   * 
   * @return
   */
  public abstract void getContent(StringBuilder result);

  public void setHovered(boolean hovered)
  {
    this.hovered = hovered;
  }

  public boolean isHovered()
  {
    return hovered;
  }

  protected void setSize(Dimension size)
  {
    this.size = size;
  }

  public Dimension getSize()
  {
    return size;
  }

  /**
   * @return Returns the selected.
   */
  public boolean isSelected()
  {
    return selected;
  }

  /**
   * @param selected
   *          The selected to set.
   */
  public void setSelected(boolean selected)
  {
    this.selected = selected;
  }

  /**
   * @return the hideContent
   */
  public boolean isHideContent()
  {
    return hideContent;
  }

  /**
   * @param hideContent
   *          the hideContent to set
   */
  public void setHideContent(boolean hideContent)
  {
    this.hideContent = hideContent;
  }

  /**
   * @return Returns the beforeLength.
   */
  public int getBeforeLength()
  {
    return beforeLength;
  }

  /**
   * @return Returns the afterLength.
   */
  public int getAfterLength()
  {
    return afterLength;
  }

  public int getIndexCount()
  {
    return beforeLength + this.getAtomCount() + afterLength;
  }

  public String getStyleKey()
  {
    return styleKey;
  }

  public void setStyleKey(String styleKey)
  {
    this.styleKey = styleKey;
  }

  /**
   * @return Returns the styleStateKey.
   */
  public String getStyleStateKey()
  {
    return styleStateKey;
  }

  /**
   * @param styleStateKey The styleStateKey to set.
   */
  public void setStyleStateKey(String styleStateKey)
  {
    this.styleStateKey = styleStateKey;
  }
}
